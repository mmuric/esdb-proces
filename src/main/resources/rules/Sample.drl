import com.execute.obj.Message;
import com.execute.obj.event.SpinningHi;
import com.execute.obj.event.SpeedLimit;
import org.goodoldai.jeff.wizard.JEFFWizard;
import java.util.Date;
import java.text.DecimalFormat;

global JEFFWizard wizard;


// eliminaciona pravila
rule "Rule 01 If there is no traveled distance, there will be no report"
	when
		m : Message( totalTraveledDistance == 0 )	
	then
		System.out.println("Ima manje od nula");
		m.setReport("There is no report for this driver");
		update(m);
		drools.halt();
end

rule "Rule 02 There is no irregular behavior of the driver"
		lock-on-active
	when
		m : Message( totalTraveledDistance >= totalDistanceMidKm, totalEvents == 0 )
	then
		System.out.println("Driver is exelent");
		m.setPartSpeedLimit(0);
		m.setPartSkiddingHi(0);
		m.setPartDecMid(0);
		m.setPartDecHi(0);
		m.setPartCorneringMid(0);
		m.setPartCorneringHi(0);
		m.setPartBarrierAvoidanceMid(0);
		m.setPartBarrierAvoidanceHi(0);
		m.setPartAggressiveLaneChangeMid(0);
		m.setPartAggressiveLaneChangeHi(0);
		m.setPartAccMid(0);
		m.setPartAccHi(0);
		m.setPartAbruptTurningHi(0);
		update(m);
end
		
rule "Rule 04 limit of negative score is 0"
	when
		m : Message( totalTraveledDistance >= totalDistanceZeroKm, totalTraveledDistance <= totalDistanceMidKm, maxEvent == 0 )
	then
		System.out.println(" limit of negative score is 0");
		m.setMaxEvent(1);
		m.setLimit(0);
		update(m);
end

rule "Rule 05 set number of events, per travel distance"
	when
		m : Message( totalTraveledDistance > totalDistanceMidKm, maxEvent == 0 )
	then
		float distanceRount = m.getTotalTraveledDistance() / 1000;
		int result = (int)  Math.ceil( distanceRount * m.getTotalEventPerKm() );
		System.out.println("maximum number of event is " + result);
		m.setMaxEvent(result);
		update(m);
end  

rule "Rule 06 set limit of negative points for traveled distance below than average"				
	when
		m : Message( maxEvent > 0, limit == 0, totalTraveledDistance > totalDistanceMidKm, totalTraveledDistance <= totalDistanceAverageKm, maxEvent: maxEvent )
	then	
		int bonusPoints = (int)  Math.ceil((1-(m.getTotalTraveledDistance() / m.getTotalDistanceAverageKm()))*100);
		System.out.println("Max number of event: " + m.getMaxEvent() + " bonus: " + bonusPoints + " and limit is: " + m.getLimit());		
		m.setLimit( maxEvent + bonusPoints );
		update(m);		
end

rule "Rule 07 set limit of negative points for traveled distance below than high"			
	when
		m : Message( maxEvent > 0, limit == 0, totalTraveledDistance > totalDistanceAverageKm, totalTraveledDistance <= totalDistanceHiKm, maxEvent: maxEvent )
	then	
		int bonusPoints = (int)  Math.ceil((1-(m.getTotalTraveledDistance() / m.getTotalDistanceHiKm()))*200);
		System.out.println("Max number of event: " + m.getMaxEvent() + " bonus: " + bonusPoints + " and limit is: " + m.getLimit());
		m.setLimit( maxEvent + bonusPoints );		
		update(m);				
end

rule "Rule 08 set limit of negative points for traveled distance over than high"			
	when
		m : Message( maxEvent > 0, limit == 0, totalTraveledDistance > totalDistanceHiKm, maxEvent: maxEvent )
	then	
		int bonusPoints = (int)  Math.ceil((1-((m.getTotalTraveledDistance() - m.getTotalDistanceHiKm() )/ m.getTotalDistanceHiKm()))*100);
		System.out.println("Max number of event: " + m.getMaxEvent() + " bonus: " + bonusPoints + " and limit is: " + m.getLimit());
		m.setLimit( maxEvent + bonusPoints );		
		update(m);				
end

rule "Rule 09 set acceleration points for severity level medium if numMidAcc is less than allowed"
	when
		m : Message( (float)(numMidAcc/totalTraveledDistance) <= (float)(eventPerKmAccMid/kmBase), partAccMid == Integer.MIN_VALUE ) 
	then
		m.setPartAccMid(0);
		update(m);
		System.out.println( "no acc point for severity level midium: " + m.getPartAccMid() );
end

rule "Rule 10 set acceleration points for severity level medium if numMidAcc is greater than allowed"
	when
		m : Message( (float)(numMidAcc/totalTraveledDistance) > (float)(eventPerKmAccMid/kmBase), partAccMid == Integer.MIN_VALUE, numMidAcc: numMidAcc, eventPerKmAccMid: eventPerKmAccMid ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity1(numMidAcc, eventPerKmAccMid));
		
		m.setPartAccMid(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Acc point for severity level midium: " + m.getPartAccMid() );		
end

rule "Rule 11 set acceleration points for severity level high if numHiAcc is less than allowed"
	when
		m : Message( (float)(numHiAcc/totalTraveledDistance) <= (float)(eventPerKmAccHi/kmBase), partAccHi == Integer.MIN_VALUE ) 
	then
		m.setPartAccHi(0);
		update(m);
		System.out.println( "no acc point for severity level midium: " + m.getPartAccHi() );
end

rule "Rule 12 set acceleration points for severity level high if numHiAcc is greater than allowed"
	when
		m : Message( (float)(numHiAcc/totalTraveledDistance) > (float)(eventPerKmAccHi/kmBase), partAccHi == Integer.MIN_VALUE, numHiAcc: numHiAcc, eventPerKmAccHi: eventPerKmAccHi ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity2(numHiAcc, eventPerKmAccHi));
		
		m.setPartAccHi(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Acc point for severity level high: " + m.getPartAccHi() );		
end

rule "Rule 13 set deceleration points for severity level medium if numMidDec is less than allowed"
	when
		m : Message( (float)(numMidDec/totalTraveledDistance) <= (float)(eventPerKmDecMid/kmBase), partDecMid == Integer.MIN_VALUE ) 
	then
		m.setPartDecMid(0);
		update(m);
		System.out.println( "no dec point for severity level midium: " + m.getPartDecMid() );
end

rule "Rule 14 set deceleration points for severity level medium if numMidDec is greater than allowed"
	when
		m : Message( (float)(numMidDec/totalTraveledDistance) > (float)(eventPerKmDecMid/kmBase), partDecMid == Integer.MIN_VALUE, numMidDec: numMidDec, eventPerKmDecMid: eventPerKmDecMid  ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity1(numMidDec, eventPerKmDecMid));
		
		m.setPartDecMid(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Dec point for severity level midium: " + m.getPartDecMid() );		
end

rule "Rule 15 set deceleration points for severity level high if numHiDec is less than allowed"
	when
		m : Message( (float)(numHiDec/totalTraveledDistance) <= (float)(eventPerKmDecHi/kmBase), partDecHi == Integer.MIN_VALUE ) 
	then
		m.setPartDecHi(0);
		update(m);
		System.out.println( "no dec point for severity level hi: " + m.getPartDecHi() );
end

rule "Rule 16 set deceleration points for severity level hi if numHiDec is greater than allowed"
	when
		m : Message( (float)(numHiDec/totalTraveledDistance) > (float)(eventPerKmDecHi/kmBase), partDecHi == Integer.MIN_VALUE, numHiDec: numHiDec, eventPerKmDecHi: eventPerKmDecHi ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity2(numHiDec, eventPerKmDecHi));
		
		m.setPartDecHi(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Dec point for severity level midium: " + m.getPartDecHi() );		
end

rule "Rule 17 set harsh cornering points for severity level mid if numHiDec is less than allowed"
	when
		m : Message( (float)(numMidCornering/totalTraveledDistance) <= (float)(eventPerKmCorneringMid/kmBase), partCorneringMid == Integer.MIN_VALUE ) 
	then
		m.setPartCorneringMid(0);
		update(m);
		System.out.println( "no harsh cornering point for severity level mid: " + m.getPartCorneringMid() );
end

rule "Rule 18 set harsh cornering points for severity level mid if numMidCornering is greater than allowed"
	when
		m : Message( (float)(numMidCornering/totalTraveledDistance) > (float)(eventPerKmCorneringMid/kmBase), partCorneringMid == Integer.MIN_VALUE, numMidCornering: numMidCornering, eventPerKmCorneringMid: eventPerKmCorneringMid ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity1(numMidCornering, eventPerKmCorneringMid));
		
		m.setPartCorneringMid(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Harsh cornering point for severity level midium: " + m.getPartCorneringMid() );		
end

rule "Rule 19 set harsh cornering points for severity level hi if numHiDec is less than allowed"
	when
		m : Message( (float)(numHiCornering/totalTraveledDistance) <= (float)(eventPerKmCorneringHi/kmBase), partCorneringHi == Integer.MIN_VALUE ) 
	then
		m.setPartCorneringHi(0);
		update(m);
		System.out.println( "no harsh cornering point for severity level hi: " + m.getPartCorneringMid() );
end

rule "Rule 20 set harsh cornering points for severity level hi if numHiDec is greater than allowed"
	when
		m : Message( (float)(numHiCornering/totalTraveledDistance) > (float)(eventPerKmCorneringHi/kmBase), partCorneringHi == Integer.MIN_VALUE, numHiCornering: numHiCornering, eventPerKmCorneringHi: eventPerKmCorneringHi ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity2(numHiCornering, eventPerKmCorneringHi));
		
		m.setPartCorneringHi(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Harsh cornering point for severity level hi: " + m.getPartCorneringHi() );		
end

rule "Rule 21 set vehicle skidding points if numHiSkidding is less than allowed"
	when
		m : Message( (float)(numHiSkidding/totalTraveledDistance) <= (float)(eventPerKmSkiddingHi/kmBase), partSkiddingHi == Integer.MIN_VALUE ) 
	then
		m.setPartSkiddingHi(0);
		update(m);
		System.out.println( "no vehicle skidding: " + m.getPartSkiddingHi() );
end

rule "Rule 22 set vehicle skidding points if numHiSkidding is greater than allowed"
	when
		m : Message( (float)(numHiSkidding/totalTraveledDistance) > (float)(eventPerKmSkiddingHi/kmBase), partSkiddingHi == Integer.MIN_VALUE, numHiSkidding: numHiSkidding, eventPerKmSkiddingHi: eventPerKmSkiddingHi ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity2(numHiSkidding, eventPerKmSkiddingHi));
		
		m.setPartSkiddingHi(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Vehicle skidding: " + m.getPartSkiddingHi() );		
end

rule "Rule 23 set abrupt turning points if numHiAbruptTurning is less than allowed"
	when
		m : Message( (float)(numHiAbruptTurning/totalTraveledDistance) <= (float)(eventPerKmAbruptTurningHi/kmBase), partAbruptTurningHi == Integer.MIN_VALUE ) 
	then
		m.setPartAbruptTurningHi(0);
		update(m);
		System.out.println( "No abrupt turning: " + m.getPartAbruptTurningHi() );
end

rule "Rule 24 set abrupt turning points if numHiAbruptTurning is greater than allowed"
	when
		m : Message( (float)(numHiAbruptTurning/totalTraveledDistance) > (float)(eventPerKmSkiddingHi/kmBase), partAbruptTurningHi == Integer.MIN_VALUE, numHiAbruptTurning: numHiAbruptTurning, eventPerKmAbruptTurningHi: eventPerKmAbruptTurningHi ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity2(numHiAbruptTurning, eventPerKmAbruptTurningHi));
		
		m.setPartAbruptTurningHi(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Abrupt turning: " + m.getPartAbruptTurningHi() );		
end

rule "Rule 25 set aggressive lane change points if numMidAggressiveLaneChange is less than allowed"
	when
		m : Message( (float)(numMidAggressiveLaneChange/totalTraveledDistance) <= (float)(eventPerKmAggressiveLaneChangeMid/kmBase), partAggressiveLaneChangeMid == Integer.MIN_VALUE ) 
	then
		m.setPartAggressiveLaneChangeMid(0);
		update(m);
		System.out.println( "no aggressive lane change severity 1: " + m.getPartAggressiveLaneChangeMid() );
end

rule "Rule 26 set aggressive lane change points if numMidAggressiveLaneChange is greater than allowed"
	when
		m : Message( (float)(numMidAggressiveLaneChange/totalTraveledDistance) > (float)(eventPerKmAggressiveLaneChangeMid/kmBase), partAggressiveLaneChangeMid == Integer.MIN_VALUE, numMidAggressiveLaneChange: numMidAggressiveLaneChange, eventPerKmAggressiveLaneChangeMid: eventPerKmAggressiveLaneChangeMid ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity1(numMidAggressiveLaneChange, eventPerKmAggressiveLaneChangeMid));
		
		m.setPartAggressiveLaneChangeMid(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Aggressive lane change for severity 1: " + m.getPartAggressiveLaneChangeMid() );		
end

rule "Rule 27 set aggressive lane change points if numHiAggressiveLaneChange is less than allowed"
	when
		m : Message( (float)(numHiAggressiveLaneChange/totalTraveledDistance) <= (float)(eventPerKmAggressiveLaneChangeHi/kmBase), partAggressiveLaneChangeHi == Integer.MIN_VALUE ) 
	then
		m.setPartAggressiveLaneChangeHi(0);
		update(m);
		System.out.println( "no aggressive lane change severity 2: " + m.getPartAggressiveLaneChangeHi() );
end

rule "Rule 28 set aggressive lane change points if numHiAggressiveLaneChange is greater than allowed"
	when
		m : Message( (float)(numHiAggressiveLaneChange/totalTraveledDistance) > (float)(eventPerKmAggressiveLaneChangeHi/kmBase), partAggressiveLaneChangeHi == Integer.MIN_VALUE, numHiAggressiveLaneChange: numHiAggressiveLaneChange, eventPerKmAggressiveLaneChangeHi: eventPerKmAggressiveLaneChangeHi ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity2(numHiAggressiveLaneChange, eventPerKmAggressiveLaneChangeHi));
		
		m.setPartAggressiveLaneChangeHi(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Aggressive lane change for severity 2: " + m.getPartAggressiveLaneChangeHi() );		
end

rule "Rule 29 set barrier avoidance points if numMidBarrierAvoidance is less than allowed"
	when
		m : Message( (float)(numMidBarrierAvoidance/totalTraveledDistance) <= (float)(eventPerKmBarrierAvoidanceMid/kmBase), partBarrierAvoidanceMid == Integer.MIN_VALUE ) 
	then
		m.setPartBarrierAvoidanceMid(0);
		update(m);
		System.out.println( "no barrier avoidance severity 1: " + m.getPartBarrierAvoidanceMid() );
end

rule "Rule 30 set barrier avoidance points if numMidBarrierAvoidance is greater than allowed"
	when
		m : Message( (float)(numMidBarrierAvoidance/totalTraveledDistance) > (float)(eventPerKmBarrierAvoidanceMid/kmBase), partBarrierAvoidanceMid  == Integer.MIN_VALUE, numMidBarrierAvoidance: numMidBarrierAvoidance, eventPerKmBarrierAvoidanceMid: eventPerKmBarrierAvoidanceMid ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity1(numMidBarrierAvoidance, eventPerKmBarrierAvoidanceMid));
		
		m.setPartBarrierAvoidanceMid(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Barrier avoidance for severity 1: " + m.getPartBarrierAvoidanceMid() );		
end

rule "Rule 31 set barrier avoidance points if numHiBarrierAvoidance is less than allowed"
	when
		m : Message( (float)(numHiBarrierAvoidance/totalTraveledDistance) <= (float)(eventPerKmBarrierAvoidanceHi/kmBase), partBarrierAvoidanceHi  == Integer.MIN_VALUE ) 
	then
		m.setPartBarrierAvoidanceHi(0);
		update(m);
		System.out.println( "no barrier avoidance severity 2: " + m.getPartBarrierAvoidanceHi() );
end

rule "Rule 32 set barrier avoidance points if numHiBarrierAvoidance is greater than allowed"
	when
		m : Message( (float)(numHiBarrierAvoidance/totalTraveledDistance) > (float)(eventPerKmBarrierAvoidanceHi/kmBase), partBarrierAvoidanceHi == Integer.MIN_VALUE, numHiBarrierAvoidance: numHiBarrierAvoidance, eventPerKmBarrierAvoidanceHi: eventPerKmBarrierAvoidanceHi ) 
	then		
		int points = (int)  Math.ceil(m.getPointsForSeverity2(numHiBarrierAvoidance, eventPerKmBarrierAvoidanceHi));
		
		m.setPartBarrierAvoidanceHi(points);
		m.setTotal(m.getTotal() + points);
		update(m);
		System.out.println( "Barrier avoidance for severity 2: " + m.getPartBarrierAvoidanceHi() );		
end

rule "Rule 33 check if spinning is allowed"
	when
		m: Message( numHiSpinning > 0, numHiSpinningAllowed == Integer.MIN_VALUE)
		exists SpinningHi(datetimeTriggered > m.getDateFrom(), datetimeTriggered < m.getDateTo()) from m.getSpinningList()
	then
		int count = 0;
		Date dateFrom = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(m.getDateFrom() + " 00:00:00"); 
		Date dateTo = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(m.getDateTo() + " 00:00:00");
		
		for(SpinningHi sh : m.getSpinningList()) {
			Date datetimeTriggered = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(sh.getDatetimeTriggered());
			if ( dateFrom.before(datetimeTriggered) && dateTo.after(datetimeTriggered) ) {
				count++;
			}			
		}
		
		System.out.println("dozvoljeno " +count);

		m.setNumHiSpinningAllowed(count);
		update(m);
end

rule "Rule 33 check if spinning is not allowed"
	when
		m: Message( numHiSpinning > 0, numHiSpinningNotAllowed == Integer.MIN_VALUE)
		exists SpinningHi(datetimeTriggered < m.getDateFrom() || datetimeTriggered > m.getDateTo()) from m.getSpinningList()
	then
		int count = 0;
		Date dateFrom = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(m.getDateFrom() + " 00:00:00"); 
		Date dateTo = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(m.getDateTo() + " 00:00:00");
		
		for(SpinningHi sh : m.getSpinningList()) {
			Date datetimeTriggered = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(sh.getDatetimeTriggered());
			if ( datetimeTriggered.before(dateFrom) || datetimeTriggered.after(dateTo) ) {
				count++;
			}			
		}

		System.out.println("nije dozvoljeno " +count);

		m.setNumHiSpinningNotAllowed(count);
		update(m);
end

rule "Rule 34 set points for allowed spinning if is less than allowed"
	when
		m: Message( (float)(numHiSpinningAllowed/totalTraveledDistance) <= (float)(eventPerKmSpinningHiInWinter/kmBase), partSpinningHiAllowed == Integer.MIN_VALUE, numHiSpinningAllowed: numHiSpinningAllowed, eventPerKmSpinningHiInWinter: eventPerKmSpinningHiInWinter )
	then
		int points = 0;		
		System.out.println("negativni poeni za spinove koji su dozvoljeni a manji su od granicnih: " + points);			
		m.setPartSpinningHiAllowed(points);
		m.setTotal(m.getTotal() + points);
		update(m);	
end

rule "Rule 36 set points for allowed spinning if is greater than allowed"
	when
		m: Message( (float)(numHiSpinningAllowed/totalTraveledDistance) > (float)(eventPerKmSpinningHiInWinter/kmBase), partSpinningHiAllowed == Integer.MIN_VALUE, numHiSpinningAllowed: numHiSpinningAllowed, eventPerKmSpinningHiInWinter: eventPerKmSpinningHiInWinter )
	then
		float n = ((numHiSpinningAllowed-eventPerKmSpinningHiInWinter)/eventPerKmSpinningHiInWinter) * 100;
		int points = (int)  Math.ceil(numHiSpinningAllowed + n);
		
		System.out.println("negativni poeni za spinove koji su dozvoljeni " + points);
			
		m.setPartSpinningHiAllowed(points);
		m.setTotal(m.getTotal() + points);
		update(m);	
end

rule "Rule 37 set points for spinning if is less than allowed"
	when
		m: Message( (float)(numHiSpinningNotAllowed/totalTraveledDistance) <= (float)(eventPerKmSpinningHi/kmBase), partSpinningHiNotAllowed == Integer.MIN_VALUE, numEvent: numHiSpinningNotAllowed )
	then
		System.out.println("Nema spina " + 0);
		m.setPartSpinningHiNotAllowed(0);
		update(m);
end

rule "Rule 38 set points for spinning if is greater than allowed"
	when
		m: Message( (float)(numHiSpinningNotAllowed/totalTraveledDistance) > (float)(eventPerKmSpinningHi/kmBase), partSpinningHiNotAllowed == Integer.MIN_VALUE, numEvent: numHiSpinningNotAllowed )
	then
		System.out.println("Ukupno spinova " + numEvent);
		m.setPartSpinningHiNotAllowed(m.getLimit() + numEvent);
		m.setTotal(m.getTotal() + m.getPartSpinningHiNotAllowed());
		m.setTypeOfDriver("extreme");
		update(m);
end

rule "Rule 39 set speed limit points if numSpeedLimit is less than allowed"
	when
		m : Message( (float)(numSpeedLimit/totalTraveledDistance) <= (float)(eventPerKmSpeedLimit/kmBase), partSpeedLimit  == Integer.MIN_VALUE ) 
	then
		m.setPartSpeedLimit(0);
		update(m);
		System.out.println( "Ovo je speed limit: " + m.getPartBarrierAvoidanceHi() );
end

rule "Rule 40 set negative points for speed limit"
	when
		m: Message((float)(numSpeedLimit/totalTraveledDistance) > (float)(eventPerKmSpeedLimit/kmBase), partSpeedLimit == Integer.MIN_VALUE) 
	then
		int points = 0;
		int i = 0;
		
		for(SpeedLimit sl: m.getSpeedLimitList()) {
			if (i >= (int) m.getEventPerKmSpeedLimit()) {
				int n = (int)  Math.ceil(((sl.getSpeedOver() - sl.getSpeedLimit())/sl.getSpeedLimit()) * 100);
				points = points + n;
			} 
			i++;
		}
		
		System.out.println("Negativni bodovi za speed limit " + points);
		
		m.setPartSpeedLimit(points);
		m.setTotal(m.getTotal() + points);
		update(m);
end
	


rule "Rule 45 Set ok status for driver"
	when 
		m: Message( typeOfDriver == "none", total < limit, ((total/ limit) *100) <= 20, total: total, limit: limit, result: ((total/limit) *100) )
	then
		Object [] content = new Object[4];
		content[0] = m.getTotalTraveledDistance();
		content[1] = limit;
		content[2] = total; 
		content[3] = result; 
		
		System.out.println( "Set ok status for driver "+ total + " " + limit);
		wizard.addTextVeryPositive("Rule 45 Set ok status for driver", content);		
		m.setTypeOfDriver("ok");
		update(m);
end

rule "Rule 46 Set border status for driver"
	when
		m: Message( typeOfDriver == "none", total < limit, ((total/ limit) *100) > 20, ((total/ limit) *100) <= 40, total: total, limit: limit, result: ((total/limit) *100) )
	then
		System.out.println( "Set border status for driver "+ total + " " + limit);
		Object [] content = new Object[4];
		content[0] = m.getTotalTraveledDistance();
		content[1] = limit;
		content[2] = total; 
		content[3] = result; 
		
		wizard.addText("Rule 46 Set border status for driver", content);
		m.setTypeOfDriver("border");
		update(m);
end

rule "Rule 47 Set risk status for driver"
	when
		m: Message( typeOfDriver == "none", total < limit, ((total/ limit) *100) > 40, ((total/ limit) *100) <= 70, total: total, limit: limit, result: ((total/limit) *100) )
	then
		System.out.println( "Set risk status for driver "+ total + " " + limit);
		Object [] content = new Object[4];
		content[0] = m.getTotalTraveledDistance();
		content[1] = limit;
		content[2] = total; 
		content[3] = result; 
		
		wizard.addTextWarning("Rule 47 Set risk status for driver", content);
		m.setTypeOfDriver("risk");
		update(m);
end

rule "Rule 48 Set agresive status for driver"
	when
		m: Message(typeOfDriver == "none", ((total/ limit) *100) > 70, ((total/ limit) *100) <= 100, total: total, limit: limit, result: ((total/ limit) *100) )
	then
		System.out.println( "Set agresive status for driver " + total + " " + limit + " " + m.getPartAccHi());
		Object [] content = new Object[4];
		content[0] = m.getTotalTraveledDistance();
		content[1] = limit;
		content[2] = total; 
		content[3] = result; 
				
		wizard.addTextNegative("Rule 48 Set agresive status for driver", content);
		//wizard.addText(null, "Set border status for driver", null, content);
		m.setTypeOfDriver("agresive");
		update(m);
end
	
rule "Rule 49 Set extreme status for driver"
	when
		m: Message( typeOfDriver == "none", total > limit, total: total, limit: limit, result: ((limit - total/ limit) *100) )
	then
		System.out.println( "Set extreme status for driver " + total + " " + limit);
		
		Object [] content = new Object[4];
		content[0] = m.getTotalTraveledDistance();
		content[1] = limit;
		content[2] = total; 
		content[3] = result;
		
		wizard.addTextVeryNegative("Rule 49 Set extreme status for driver", content);
		m.setTypeOfDriver("extreme");
		update(m);
end

rule "Rule 41 Postavi eventOfLowerImportance"
	when
		m: Message( total > 0, eventOfLowerImportance == Integer.MIN_VALUE, limit: limit )
	then
		float lowImportance = (m.getPartAccHi()/limit + m.getPartAccMid()/limit + m.getPartDecHi()/limit + m.getPartDecMid()/limit + m.getPartCorneringHi()/limit + m.getPartCorneringMid()/limit + m.getPartSpeedLimit()/limit) / 7;
		
		System.out.println(lowImportance);
		
		m.setEventOfLowerImportance((float)lowImportance);
		update(m);
end

rule "Rule 42 Postavi eventOfHighImportance"
	when
		m: Message( total > 0, eventOfHighImportance == Integer.MIN_VALUE, limit: limit )
	then
		float highImportance = (m.getPartAbruptTurningHi()/limit + m.getPartAggressiveLaneChangeHi()/limit + m.getPartAggressiveLaneChangeMid()/limit + m.getPartBarrierAvoidanceHi()/limit + m.getPartBarrierAvoidanceMid()/limit + m.getPartSkiddingHi()/limit) / 6;
			
		System.out.println(highImportance);
		
		m.setEventOfHighImportance(highImportance);
		update(m);
end

// da li ucestvuje u ukupnoj sumi preko 50%, koji je tip drivera, da li je obradjivan

rule "Rule 76 Set text for SpinningHiAllowed if driver is agresive"
	when
		m: Message( partSpinningHiAllowed > 0, processedSpinningHiAllowed == "No")
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[5];
		content[0] = m.getNumHiSpinningAllowed();
		content[1] = m.getPartSpinningHiAllowed();
		content[2] = df.format((m.getPartSpinningHiAllowed() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Vehicle Spinning Allowed severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovi dogadjaji desili su se u periodu izmedju " + content[3] + " i " + content[4] + ". Ovde treba kao olaksavajucu okolnost uzeti vremenske uslove.");
		
		Date dateFrom = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(m.getDateFrom() + " 00:00:00"); 
		Date dateTo = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(m.getDateTo() + " 00:00:00");
		
		for(SpinningHi sh : m.getSpinningList()) {
			Date datetimeTriggered = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(sh.getDatetimeTriggered());
			if ( dateFrom.before(datetimeTriggered) && dateTo.after(datetimeTriggered) ) {
				System.out.println("Neko suntavo objasnjenje\t" + sh.getDatetimeTriggered() + "\tmax speed\tduration");
			}
		}
		
		m.setProcessedSpinningHiAllowed("Yes");
		update(m);
end 

rule "Rule 77 Execute spinning rule"
	when
		m: Message( partSpinningHiNotAllowed > 0, processedSpinningHiNotAllowed == "No" )
	then
		Object [] content = new Object[5];
		System.out.println("Ovako");
		
		Date dateFrom = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(m.getDateFrom() + " 00:00:00"); 
		Date dateTo = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(m.getDateTo() + " 00:00:00");
		
		for(SpinningHi sh : m.getSpinningList()) {
			Date datetimeTriggered = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(sh.getDatetimeTriggered());
			if ( datetimeTriggered.before(dateFrom) || datetimeTriggered.after(dateTo) ) {
				System.out.println("Neko suntavo objasnjenje\t" + sh.getDatetimeTriggered() + "\tmax speed\tduration");
			}
		}	
		
		m.setProcessedSpinningHiNotAllowed("Yes");
		update(m);	
end

rule "Rule 43 Set text for AccHi for ok driver behavior"
	when
		m: Message( typeOfDriver == "ok" , partAccHi/total > eventOfLowerImportance, processedAccHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiAcc();
		content[1] = m.getPartAccHi();
		content[2] = df.format((m.getPartAccHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Harsh acceleration severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, sto dokazuje nasu tvrdnju da je ovaj vozac primeran vozac.");
		m.setProcessedAccHi("Yes");
		update(m);
end 

rule "Rule 44 Set text for AccMid for ok driver behavior"
	when
		m: Message( typeOfDriver == "ok" , partAccMid/total > eventOfLowerImportance, processedAccMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidAcc();
		content[1] = m.getPartAccMid();
		content[2] = df.format((m.getPartAccMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Harsh acceleration severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, sto dokazuje nasu tvrdnju da je ovaj vozac primeran vozac.");
		m.setProcessedAccMid("Yes");
		update(m);
end 

rule "Rule 45 Set text for DecHi for ok driver behavior"
	when
		m: Message( typeOfDriver == "ok" , partDecHi/total > eventOfLowerImportance, processedDecHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiDec();
		content[1] = m.getPartDecHi();
		content[2] = df.format((m.getPartDecHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Harsh deceleration severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, sto dokazuje nasu tvrdnju da je ovaj vozac primeran vozac.");
		m.setProcessedDecHi("Yes");
		update(m);
end

rule "Rule 46 Set text for DecMid for ok driver behavior"
	when
		m: Message( typeOfDriver == "ok" , partDecMid/total > eventOfLowerImportance, processedDecMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidDec();
		content[1] = m.getPartDecMid();
		content[2] = df.format((m.getPartDecMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Harsh deceleration severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, sto dokazuje nasu tvrdnju da je ovaj vozac primeran vozac.");
		m.setProcessedDecMid("Yes");
		update(m);
end

rule "Rule 47 Set text for CorneringHi for ok driver behavior"
	when
		m: Message( typeOfDriver == "ok" , partCorneringHi/total > eventOfLowerImportance, processedCorneringHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiCornering();
		content[1] = m.getPartCorneringHi();
		content[2] = df.format((m.getPartCorneringHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Cornering severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, sto dokazuje nasu tvrdnju da je ovaj vozac primeran vozac.");
		m.setProcessedCorneringHi("Yes");
		update(m);
end

rule "Rule 48 Set text for CorneringMid for ok driver behavior"
	when
		m: Message( typeOfDriver == "ok" , partCorneringMid/total > eventOfLowerImportance, processedCorneringMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidCornering();
		content[1] = m.getPartCorneringMid();
		content[2] = df.format((m.getPartCorneringMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Cornering severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, sto dokazuje nasu tvrdnju da je ovaj vozac primeran vozac.");
		m.setProcessedCorneringMid("Yes");
		update(m);
end

rule "Rule 49 Set text for Speed limit for ok driver behavior"
	when
		m: Message( typeOfDriver == "ok" , partSpeedLimit/total > eventOfLowerImportance, processedSpeedLimit == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumSpeedLimit();
		content[1] = m.getPartSpeedLimit();
		content[2] = df.format((m.getPartSpeedLimit() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Speed limit notification' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, sto dokazuje nasu tvrdnju da je ovaj vozac primeran vozac.");
		m.setProcessedSpeedLimit("Yes");
		update(m);
end

rule "Rule 50 Set text for AbruptTurningHi for ok driver behavior"
	when
		m: Message( typeOfDriver == "ok", partAbruptTurningHi/total > eventOfHighImportance, processedAbruptTurningHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiAbruptTurning();
		content[1] = m.getPartAbruptTurningHi();
		content[2] = df.format((m.getPartAbruptTurningHi() / m.getLimit())*100);	
		System.out.println("Ukupan broj dogadjaja 'Abrupt turning severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, Ali ipak treba skrenuti paznju vozacu kako nebi znacajno presao dozvoljeni limit.");
		m.setProcessedAbruptTurningHi("Yes");
		update(m);
end 

rule "Rule 51 Set text for AggressiveLaneChangeHi for ok driver behaviour"
	when
		m: Message( typeOfDriver == "ok", partAggressiveLaneChangeHi/total > eventOfHighImportance, processedAggressiveLaneChangeHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiAggressiveLaneChange();
		content[1] = m.getPartAggressiveLaneChangeHi();
		content[2] = df.format((m.getPartAggressiveLaneChangeHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Abrupt turning severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, Ali ipak treba skrenuti paznju vozacu kako nebi znacajno presao dozvoljeni limit.");
		m.setProcessedAggressiveLaneChangeHi("Yes");
		update(m);
end 

rule "Rule 52 Set text for AggressiveLaneChangeMid for ok driver behaviour"
	when
		m: Message( typeOfDriver == "ok", partAggressiveLaneChangeMid/total > eventOfHighImportance, processedAggressiveLaneChangeMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumMidAggressiveLaneChange();
		content[1] = m.getPartAggressiveLaneChangeMid();
		content[2] = df.format((m.getPartAggressiveLaneChangeMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Aggressive lane change severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj se generise ukoliko vozac agresivno zaobilazi vozilo ili grupu vozila. Ucesca ovog dogadjaja u ukupnoj sumi pokazuje nam da je vozac agresivan prilikom zaobilazenja drugih ucesnika u saobrcaju i da na taj nacin ugrozava kako svoju tako i bezbednost drugih.");
		m.setProcessedAggressiveLaneChangeMid("Yes");
		update(m);
end 

rule "Rule 53 Set text for BarrierAvoidanceHi for ok driver behaviour"
	when
		m: Message( typeOfDriver == "ok", partBarrierAvoidanceHi/total > eventOfHighImportance, processedBarrierAvoidanceHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiBarrierAvoidance();
		content[1] = m.getPartBarrierAvoidanceHi();
		content[2] = df.format((m.getPartAbruptTurningHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Barrier avoidance severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, Ali ipak treba skrenuti paznju vozacu kako nebi znacajno presao dozvoljeni limit.");
		m.setProcessedBarrierAvoidanceHi("Yes");
		update(m);
end 

rule "Rule 54 Set text for BarrierAvoidanceMid for ok driver behaviour"
	when
		m: Message( typeOfDriver == "ok", partBarrierAvoidanceMid/total > eventOfHighImportance, processedBarrierAvoidanceMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumMidBarrierAvoidance();
		content[1] = m.getPartBarrierAvoidanceMid();
		content[2] = df.format((m.getPartBarrierAvoidanceMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Barrier avoidance change severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, Ali ipak treba skrenuti paznju vozacu kako nebi znacajno presao dozvoljeni limit.");
		m.setProcessedBarrierAvoidanceHi("Yes");
		update(m);
end 

rule "Rule 55 Set text for SkiddingHi for ok driver behaviour"
	when
		m: Message( typeOfDriver == "ok", partSkiddingHi/total > eventOfHighImportance, processedSkiddingHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiSkidding();
		content[1] = m.getPartSkiddingHi();
		content[2] = df.format((m.getPartSkiddingHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Vehicle skidding severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj ucestvuje relativno malo u ukupnom limitu, Ali ipak treba skrenuti paznju vozacu kako nebi znacajno presao dozvoljeni limit.");
		m.setProcessedSkiddingHi("Yes");
		update(m);
end 

rule "Rule 43 Set text for AccHi for bad driver behavior"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive") , partAccHi/total > eventOfLowerImportance, processedAccHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiAcc();
		content[1] = m.getPartAccHi();
		content[2] = df.format((m.getPartAccHi() / m.getLimit())*100);
		content[3] = m.getNumHiAcc() - m.getEventPerKmAccHi();
		System.out.println("Ukupan broj dogadjaja 'Harsh acceleration severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Kako bi popravio svoje ponasanje vozac mora smanjiti agresivnost prilikom naglog ubrzanja za " + content[3] + ".");
		m.setProcessedAccHi("Yes");
		update(m);
end 

rule "Rule 44 Set text for AccMid for bad driver behavior"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive") , partAccMid/total > eventOfLowerImportance, processedAccMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidAcc();
		content[1] = m.getPartAccMid();
		content[2] = df.format((m.getPartAccMid() / m.getLimit())*100);
		content[3] = m.getNumMidAcc() - m.getEventPerKmAccMid();
		System.out.println("Ukupan broj dogadjaja 'Harsh acceleration severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Kako bi popravio svoje ponasanje vozac mora smanjiti agresivnost prilikom ubrzanja za " + content[3] + ".");
		m.setProcessedAccMid("Yes");
		update(m);
end 

rule "Rule 45 Set text for DecHi for bad driver behavior"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive") , partDecHi/total > eventOfLowerImportance, processedDecHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiDec();
		content[1] = m.getPartDecHi();
		content[2] = df.format((m.getPartDecHi() / m.getLimit())*100);
		content[3] = m.getNumHiDec() - m.getEventPerKmDecHi();
		System.out.println("Ukupan broj dogadjaja 'Harsh deceleration severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%.  Kako bi popravio svoje ponasanje vozac mora smanjiti agresivna nagla kocenja za: " + content[3] + ".");
		m.setProcessedDecHi("Yes");
		update(m);
end

rule "Rule 46 Set text for DecMid for bad driver behavior"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive") , partDecMid/total > eventOfLowerImportance, processedDecMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidDec();
		content[1] = m.getPartDecMid();
		content[2] = df.format((m.getPartDecMid() / m.getLimit())*100);
		content[3] = m.getNumMidDec() - m.getEventPerKmDecMid();
		System.out.println("Ukupan broj dogadjaja 'Harsh deceleration severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%.  Kako bi popravio svoje ponasanje vozac mora smanjiti nagla kocenja za: " + content[3] + ".");
		m.setProcessedDecMid("Yes");
		update(m);
end

rule "Rule 47 Set text for CorneringHi for bad driver behavior"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive") , partCorneringHi/total > eventOfLowerImportance, processedCorneringHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiCornering();
		content[1] = m.getPartCorneringHi();
		content[2] = df.format((m.getPartCorneringHi() / m.getLimit())*100);
		content[3] = m.getNumHiCornering() - m.getEventPerKmCorneringHi();
		System.out.println("Ukupan broj dogadjaja 'Cornering severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%.  Kako bi popravio svoje ponasanje vozac mora smanjiti agresivnost prilikom ulazenja u krivinu za: " + content[3] + " dogadjaja.");
		m.setProcessedCorneringHi("Yes");
		update(m);
end

rule "Rule 48 Set text for CorneringMid for bad driver behavior"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive") , partCorneringMid/total > eventOfLowerImportance, processedCorneringMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidCornering();
		content[1] = m.getPartCorneringMid();
		content[2] = df.format((m.getPartCorneringMid() / m.getLimit())*100);
		content[3] = m.getNumMidCornering() - m.getEventPerKmCorneringMid();
		System.out.println("Ukupan broj dogadjaja 'Cornering severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%.  Kako bi popravio svoje ponasanje vozac mora smanjiti nagle ulaske u krivinu za: " + content[3] + " dogadjaja.");
		m.setProcessedCorneringMid("Yes");
		update(m);
end

rule "Rule 49 Set text for Speed limit for bad driver behavior"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive") , partSpeedLimit/total > eventOfLowerImportance, processedSpeedLimit == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumSpeedLimit();
		content[1] = m.getPartSpeedLimit();
		content[2] = df.format((m.getPartSpeedLimit() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Speed limit notification' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj predstavlja direktno krsenje pravila ponasanja vlasnika flote. Prelazak dozvoljenog limita direktno krsi pravila kompanije i kao takvo treba biti sankcionisano.");
		m.setProcessedSpeedLimit("Yes");
		update(m);
end

rule "Rule 50 Set text for AbruptTurningHi if driver is agresive"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive"), partAbruptTurningHi/total > eventOfHighImportance, processedAbruptTurningHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiAbruptTurning();
		content[1] = m.getPartAbruptTurningHi();
		content[2] = df.format((m.getPartAbruptTurningHi() / m.getLimit())*100);	
		System.out.println("Ukupan broj dogadjaja 'Abrupt turning severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj se generise ako vozac gubi kontrolu nad vozilom prilikom skretanja. Pojava ovog dogadjaja u ukupnoj sumi negativnih bodova govori nam o tome da vozac ozbiljno ugrozava svoju bezbednost.");
		m.setProcessedAbruptTurningHi("Yes");
		update(m);
end 

rule "Rule 51 Set text for AggressiveLaneChangeHi if driver is agresive"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive"), partAggressiveLaneChangeHi/total > eventOfHighImportance, processedAggressiveLaneChangeHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiAggressiveLaneChange();
		content[1] = m.getPartAggressiveLaneChangeHi();
		content[2] = df.format((m.getPartAggressiveLaneChangeHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Aggressive lane change severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj se generise ukoliko vozac veoma agresivno zaobilazi vozilo ili grupu vozila. Ucesca ovog dogadjaja u ukupnoj sumi pokazuje nam da je vozac izuzetno agresivan prilikom zaobilazenja drugih ucesnika u saobracaju. Na ovaj nacin vozac ugrozava kako sebe tako i druge ucesnike u saobracaju.");
		m.setProcessedAggressiveLaneChangeHi("Yes");
		update(m);
end 

rule "Rule 52 Set text for AggressiveLaneChangeMid if driver is agresive"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive"), partAggressiveLaneChangeMid/total > eventOfHighImportance, processedAggressiveLaneChangeMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumMidAggressiveLaneChange();
		content[1] = m.getPartAggressiveLaneChangeMid();
		content[2] = df.format((m.getPartAggressiveLaneChangeMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Aggressive lane change severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj se generise ukoliko vozac agresivno zaobilazi vozilo ili grupu vozila. Ucesca ovog dogadjaja u ukupnoj sumi pokazuje nam da je vozac agresivan prilikom zaobilazenja drugih ucesnika u saobrcaju i da na taj nacin ugrozava kako svoju tako i bezbednost drugih.");
		m.setProcessedAggressiveLaneChangeMid("Yes");
		update(m);
end 

rule "Rule 53 Set text for BarrierAvoidanceHi if driver is agresive"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive"), partBarrierAvoidanceHi/total > eventOfHighImportance, processedBarrierAvoidanceHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiBarrierAvoidance();
		content[1] = m.getPartBarrierAvoidanceHi();
		content[2] = df.format((m.getPartAbruptTurningHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Barrier avoidance severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj se generise u slucaju kada vozac naglo pokusa da zaobidje prepreku na putu, pri tome praveci putanju u obliku latinicnog slova s. Ovaj dogadjaj ukazuje na veoma ozbiljan gubitak kontrole nad vozilom. Pojava ovog dogadjaja u totalnoj sumi negativnih bodova, ukazuje da je vozac veoma ne pazljiv i da time ugrozava bezbednost u saobracaju.");
		m.setProcessedBarrierAvoidanceHi("Yes");
		update(m);
end 

rule "Rule 54 Set text for BarrierAvoidanceMid if driver is agresive"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive"), partBarrierAvoidanceMid/total > eventOfHighImportance, processedBarrierAvoidanceMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumMidBarrierAvoidance();
		content[1] = m.getPartBarrierAvoidanceMid();
		content[2] = df.format((m.getPartBarrierAvoidanceMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Barrier avoidance change severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%. Ovaj dogadjaj se generise u slucaju kada vozac pokusa da zaobidje prepreku na putu, pri tome praveci putanju u obliku latinicnog slova s. Ovaj dogadjaj ukazuje na gubitak kontrole nad vozilom. Pojava ovog dogadjaja u totalnoj sumi negativnih bodova, ukazuje da je vozac ne pazljiv u upravljanju vozilom i da time ugrozava bezbednost u saobracaju.");
		m.setProcessedBarrierAvoidanceHi("Yes");
		update(m);
end 

rule "Rule 55 Set text for SkiddingHi if driver is agresive"
	when
		m: Message( typeOfDriver in ("border", "risk", "agresive"), partSkiddingHi/total > eventOfHighImportance, processedSkiddingHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiSkidding();
		content[1] = m.getPartSkiddingHi();
		content[2] = df.format((m.getPartSkiddingHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Vehicle skidding severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Ovi negativni bodovi ukupno ucestvuju u dozvoljenom limitu sa " + content[2] + "%.  Ovaj dogadjaj se generise kada vozilu pri ulasku u krivinu prokliza zadnji deo u odnosu na prednji (over-steering). Ovo uzrokuje nestabilnost vozila. Pojava ovog dogadjaja u ukupnoj negativnoj sumi znaci da vozac ugrozava bezbednost saobracaja veoma svojim agresivnim ponasanjem.");
		m.setProcessedSkiddingHi("Yes");
		update(m);
end 

rule "Rule 43 Set text for AccHi over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme" , partAccHi > limit, processedAccHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiAcc();
		content[1] = m.getPartAccHi();
		content[2] = df.format((m.getPartAccHi() / m.getLimit())*100);
		content[3] = m.getPartAccHi() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Harsh acceleration severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedAccHi("Yes");
		update(m);
end 

rule "Rule 44 Set text for AccMid over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme" , partAccMid > limit, processedAccMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidAcc();
		content[1] = m.getPartAccMid();
		content[2] = df.format((m.getPartAccMid() / m.getLimit())*100);
		content[3] = m.getPartAccMid() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Harsh acceleration severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedAccMid("Yes");
		update(m);
end

rule "Rule 45 Set text for DecHi over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme" , partDecHi > limit, processedDecHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiDec();
		content[1] = m.getPartDecHi();
		content[2] = df.format((m.getPartDecHi() / m.getLimit())*100);
		content[3] = m.getPartDecHi() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Harsh deceleration severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedDecHi("Yes");
		update(m);
end

rule "Rule 46 Set text for DecMid over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partDecMid > limit, processedDecMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidDec();
		content[1] = m.getPartDecMid();
		content[2] = df.format((m.getPartDecMid() / m.getLimit())*100);
		content[3] = m.getPartDecMid() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Harsh deceleration severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedDecMid("Yes");
		update(m);
end

rule "Rule 47 Set text for CorneringHi over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partCorneringHi > limit, processedCorneringHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiCornering();
		content[1] = m.getPartCorneringHi();
		content[2] = df.format((m.getPartCorneringHi() / m.getLimit())*100);
		content[3] = m.getPartCorneringHi() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Cornering severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedCorneringHi("Yes");
		update(m);
end

rule "Rule 48 Set text for CorneringMid over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partCorneringMid > limit, processedCorneringMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidCornering();
		content[1] = m.getPartCorneringMid();
		content[2] = df.format((m.getPartCorneringMid() / m.getLimit())*100);
		content[3] = m.getPartCorneringMid() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Cornering severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedCorneringMid("Yes");
		update(m);
end

rule "Rule 49 Set text for Speed limit over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partSpeedLimit > limit, processedSpeedLimit == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumSpeedLimit();
		content[1] = m.getPartSpeedLimit();
		content[2] = df.format((m.getPartSpeedLimit() / m.getLimit())*100);
		content[3] = m.getPartSpeedLimit() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Speed limit notification' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedSpeedLimit("Yes");
		update(m);
end

rule "Rule 50 Set text for AbruptTurningHi over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partAbruptTurningHi > limit, processedAbruptTurningHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiAbruptTurning();
		content[1] = m.getPartAbruptTurningHi();
		content[2] = df.format((m.getPartAbruptTurningHi() / m.getLimit())*100);
		content[3] = m.getPartAbruptTurningHi() - m.getLimit();	
		System.out.println("Ukupan broj dogadjaja 'Abrupt turning severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedAbruptTurningHi("Yes");
		update(m);
end 

rule "Rule 51 Set text for AggressiveLaneChangeHi over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partAggressiveLaneChangeHi > limit, processedAggressiveLaneChangeHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiAggressiveLaneChange();
		content[1] = m.getPartAggressiveLaneChangeHi();
		content[2] = df.format((m.getPartAggressiveLaneChangeHi() / m.getLimit())*100);
		content[3] = m.getPartAggressiveLaneChangeHi() - m.getLimit();	
		System.out.println("Ukupan broj dogadjaja 'Aggressive lane change severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedAggressiveLaneChangeHi("Yes");
		update(m);
end 

rule "Rule 52 Set text for AggressiveLaneChangeMid over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partAggressiveLaneChangeMid > limit, processedAggressiveLaneChangeMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumMidAggressiveLaneChange();
		content[1] = m.getPartAggressiveLaneChangeMid();
		content[2] = df.format((m.getPartAggressiveLaneChangeMid() / m.getLimit())*100);
		content[3] = m.getPartAggressiveLaneChangeMid() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Aggressive lane change severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedAggressiveLaneChangeMid("Yes");
		update(m);
end 

rule "Rule 53 Set text for BarrierAvoidanceHi over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partBarrierAvoidanceHi > limit, processedBarrierAvoidanceHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiBarrierAvoidance();
		content[1] = m.getPartBarrierAvoidanceHi();
		content[2] = df.format((m.getPartBarrierAvoidanceHi() / m.getLimit())*100);
		content[3] = m.getPartBarrierAvoidanceHi() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Barrier avoidance severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedBarrierAvoidanceHi("Yes");
		update(m);
end 

rule "Rule 54 Set text for BarrierAvoidanceMid over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partBarrierAvoidanceMid > limit, processedBarrierAvoidanceMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumMidBarrierAvoidance();
		content[1] = m.getPartBarrierAvoidanceMid();
		content[2] = df.format((m.getPartBarrierAvoidanceMid() / m.getLimit())*100);
		content[3] = m.getPartBarrierAvoidanceMid() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Barrier avoidance severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedBarrierAvoidanceHi("Yes");
		update(m);
end 

rule "Rule 55 Set text for SkiddingHi over limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partSkiddingHi > limit, processedSkiddingHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiSkidding();
		content[1] = m.getPartSkiddingHi();
		content[2] = df.format((m.getPartSkiddingHi() / m.getLimit())*100);
		content[3] = m.getPartSkiddingHi() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Vehicle skidding severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Kako je suma ovih bodova veca za " + content[2] + "% od ukupnog dozvoljenog limita, tj. prelazi limit za " + content[3] + " bodova. Ovo pokazuje da je nasa tvrdnja da je ovaj vozac ekstreman u potpunosti opravdana");
		m.setProcessedSkiddingHi("Yes");
		update(m);
end 





rule "Rule 43 Set text for AccHi below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme" , partAccHi < limit, processedAccHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiAcc();
		content[1] = m.getPartAccHi();
		content[2] = df.format((m.getPartAccHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Harsh acceleration severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman." );
		m.setProcessedAccHi("Yes");
		update(m);
end 

rule "Rule 44 Set text for AccMid below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme" , partAccMid < limit, processedAccMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidAcc();
		content[1] = m.getPartAccMid();
		content[2] = df.format((m.getPartAccMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Harsh acceleration severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedAccMid("Yes");
		update(m);
end

rule "Rule 45 Set text for DecHi below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme" , partDecHi < limit, processedDecHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiDec();
		content[1] = m.getPartDecHi();
		content[2] = df.format((m.getPartDecHi() / m.getLimit())*100);
		content[3] = m.getPartDecHi() - m.getLimit();
		System.out.println("Ukupan broj dogadjaja 'Harsh deceleration severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedDecHi("Yes");
		update(m);
end

rule "Rule 46 Set text for DecMid below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partDecMid < limit, processedDecMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidDec();
		content[1] = m.getPartDecMid();
		content[2] = df.format((m.getPartDecMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Harsh deceleration severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedDecMid("Yes");
		update(m);
end

rule "Rule 47 Set text for CorneringHi below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partCorneringHi < limit, processedCorneringHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumHiCornering();
		content[1] = m.getPartCorneringHi();
		content[2] = df.format((m.getPartCorneringHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Cornering severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedCorneringHi("Yes");
		update(m);
end

rule "Rule 48 Set text for CorneringMid below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partCorneringMid < limit, processedCorneringMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[4];
		content[0] = m.getNumMidCornering();
		content[1] = m.getPartCorneringMid();
		content[2] = df.format((m.getPartCorneringMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Cornering severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedCorneringMid("Yes");
		update(m);
end

rule "Rule 49 Set text for Speed limit below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partSpeedLimit < limit, processedSpeedLimit == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumSpeedLimit();
		content[1] = m.getPartSpeedLimit();
		content[2] = df.format((m.getPartSpeedLimit() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Speed limit notification' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedSpeedLimit("Yes");
		update(m);
end

rule "Rule 50 Set text for AbruptTurningHi below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partAbruptTurningHi < limit, processedAbruptTurningHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiAbruptTurning();
		content[1] = m.getPartAbruptTurningHi();
		content[2] = df.format((m.getPartAbruptTurningHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Abrupt turning severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedAbruptTurningHi("Yes");
		update(m);
end 

rule "Rule 51 Set text for AggressiveLaneChangeHi below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partAggressiveLaneChangeHi < limit, processedAggressiveLaneChangeHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiAggressiveLaneChange();
		content[1] = m.getPartAggressiveLaneChangeHi();
		content[2] = df.format((m.getPartAggressiveLaneChangeHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Aggressive lane change severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedAggressiveLaneChangeHi("Yes");
		update(m);
end 

rule "Rule 52 Set text for AggressiveLaneChangeMid below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partAggressiveLaneChangeMid < limit, processedAggressiveLaneChangeMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumMidAggressiveLaneChange();
		content[1] = m.getPartAggressiveLaneChangeMid();
		content[2] = df.format((m.getPartAggressiveLaneChangeMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Aggressive lane change severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedAggressiveLaneChangeMid("Yes");
		update(m);
end 

rule "Rule 53 Set text for BarrierAvoidanceHi below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partBarrierAvoidanceHi < limit, processedBarrierAvoidanceHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiBarrierAvoidance();
		content[1] = m.getPartBarrierAvoidanceHi();
		content[2] = df.format((m.getPartBarrierAvoidanceHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Barrier avoidance severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedBarrierAvoidanceHi("Yes");
		update(m);
end 

rule "Rule 54 Set text for BarrierAvoidanceMid below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partBarrierAvoidanceMid < limit, processedBarrierAvoidanceMid == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumMidBarrierAvoidance();
		content[1] = m.getPartBarrierAvoidanceMid();
		content[2] = df.format((m.getPartBarrierAvoidanceMid() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Barrier avoidance severity level Mid' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedBarrierAvoidanceHi("Yes");
		update(m);
end 

rule "Rule 55 Set text for SkiddingHi below the limit for extreme drivers"
	when
		m: Message( typeOfDriver == "extreme", partSkiddingHi < limit, processedSkiddingHi == "No" )
	then
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(2);
		Object [] content = new Object[3];
		content[0] = m.getNumHiSkidding();
		content[1] = m.getPartSkiddingHi();
		content[2] = df.format((m.getPartSkiddingHi() / m.getLimit())*100);
		System.out.println("Ukupan broj dogadjaja 'Vehicle skidding severity level Hi' iznosi: " + content[0] + " koji na ukupnu predjenu kilometrazu iznosi " + content[1] + " negativnih bodova. Suma ovih bodova ucestvuje u ukupnom limitu sa " + content[2] + "%, sto podrzava tvrdnju da je ovaj vozac ekstreman.");
		m.setProcessedSkiddingHi("Yes");
		update(m);
end









rule "Rule 56 Additionally conclusion about speeding"
	when
		m: Message( typeOfDriver in ("ok", "border", "risk", "agresive"), additionallyConclusion1 == "No") and 
		( Message( processedAccHi == "Yes", processedAccMid == "Yes" ) or
		  Message( processedAccHi == "Yes", processedSpeedLimit == "Yes" ) or
		  Message( processedAccMid == "Yes", processedSpeedLimit == "Yes" ) or
		  Message( processedAccHi == "Yes", processedAccMid == "Yes", processedSpeedLimit == "Yes" ) )
	then
		System.out.println("Ocigledno je da ovaj vozac voli da vozi brzo. Treba delovati savetodavno da smanji brzinu prilikom voznje kako bi se smanjili i negativni poeni koje on pravi ovakvim ponasanjem");
		m.setAdditionallyConclusion1("Yes");
		update(m);
end

rule "Rule 57 Additionally conclusion about avoidance"
	when
		m: Message( typeOfDriver in ("ok", "border", "risk", "agresive"), additionallyConclusion2 == "No") and
		( Message( processedDecHi == "Yes", processedDecHi == "Yes" ) or
		  Message( processedBarrierAvoidanceHi == "Yes", processedBarrierAvoidanceMid == "Yes" ) or 
		  ( Message( processedDecHi == "Yes" || processedDecHi == "Yes" ) and
		    Message( processedBarrierAvoidanceHi == "Yes" || processedBarrierAvoidanceMid == "Yes" ) )
		)
	then
		System.out.println("Ovaj vozac je ocigledno nepazljiv prilikom voznje. Trebalo bi ga savetovati da vodi vise racuna prilikom voznje kako bi smanjio broj negativnih poena");
		m.setAdditionallyConclusion2("Yes");
		update(m);
end;

rule "Rule 58 Additionally conclusion about cornering"
	when
		m: Message( typeOfDriver in ("ok", "border", "risk", "agresive"), additionallyConclusion3 == "No") and
		( Message( typeOfDriver in ("ok", "border", "risk", "agresive"), processedCorneringHi == "Yes", processedCorneringMid  == "Yes" ) or
		  Message( typeOfDriver in ("ok", "border", "risk", "agresive"), processedAbruptTurningHi == "Yes", processedSkiddingHi == "Yes") or
		  ( Message( typeOfDriver in ("ok", "border", "risk", "agresive"), processedCorneringHi == "Yes" || processedCorneringMid  == "Yes" ) and 
		    Message( typeOfDriver in ("ok", "border", "risk", "agresive"), processedAbruptTurningHi == "Yes" || processedSkiddingHi == "Yes") )
	    )	
	then
		System.out.println("Vozac ocigledno voli da rizikuje u krivini. Trebalo bi ga savetovati da malo laganije ulazi u krivinu kako bi smanjio ukupan broj negativnih bodova.");
		m.setAdditionallyConclusion3("Yes");
		update(m);
end






		


